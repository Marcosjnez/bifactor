% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/cpp_functions.R
\name{bifactor}
\alias{bifactor}
\title{Fit an exploratory bi-factor or generalized bi-factor model.}
\usage{
bifactor(R, n_generals, n_groups, bifactor_method = "GSLiD", projection = "oblq",
PhiTarget = NULL, PhiWeight = NULL,
blocks = NULL, blocks_list = NULL, block_weights = NULL,
oblq_blocks = NULL, init_Target = NULL, method = "minres", maxit = 20L,
cutoff = 0, w = 1, random_starts = 1L, cores = 1L, init = NULL,
efa_control = NULL, rot_control = NULL,
SL_first_efa = NULL, SL_second_efa = NULL, verbose = TRUE)
}
\arguments{
\item{R}{Correlation matrix.}

\item{n_generals}{Number of general factors to extract.}

\item{n_groups}{Number of group factors to extract.}

\item{bifactor_method}{"GSLiD" and "SL" (Schmid-Leiman) Defaults to "GSLiD".}

\item{projection}{Projection method. Available projections: "orth" (orthogonal), "oblq" (oblique) and "poblq" (partially oblique). Defaults to "oblq".}

\item{PhiTarget}{Target matrix for the factor correlations. Defaults to NULL.}

\item{PhiWeight}{Weight matrix for the factor correlations. Defaults to NULL.}

\item{blocks}{Vector with the number of factors for which separately applying the rotation criterion. Defaults to NULL.}

\item{blocks_list}{List containing the columns to which applying the rotation criterion.}

\item{block_weights}{Vector of weights for each block of factors.}

\item{oblq_blocks}{Vector with the number of factors for each oblique block. E.g.: c(2, 4) means that there are two blocks of oblique factors: one block with 2 factors and another block with 4 factors. Everything else is orthogonal. Defaults to NULL.}

\item{init_Target}{Initial target matrix for the loadings. Defaults to NULL.}

\item{method}{EFA fitting method: "ml" (maximum likelihood for multivariate normal variable), "minres" (minimum residuals), "pa" (principal axis) or "minrank" (minimum rank). Defaults to "minres".}

\item{maxit}{Maximum number of iterations for the GSLiD algorithm. Defaults to 20L.}

\item{cutoff}{Cut-off used to update the target matrix upon each iteration. Defaults to 0.}

\item{w}{\eqn{w} parameter for the extended target criterion ("xtarget"). Defaults to 1L.}

\item{random_starts}{Number of rotations with different random starting values. The rotation with the smallest cost function value is returned. Defaults to 1L.}

\item{cores}{Number of cores for parallel execution of multiple rotations. Defaults to 1L.}

\item{init}{Initial uniquenesses values for exploratory factor analsyis estimation. Defaults to NULL.}

\item{efa_control}{List of control parameters for efa fitting. Defaults to NULL.}

\item{rot_control}{List of control parameters for the rotation algorithm. Defaults to NULL.}

\item{SL_first_efa}{List of arguments to pass to \code{efast} to perform the first-order solution for the Schmid-Leiman method. Defaults to NULL.}

\item{SL_second_efa}{List of arguments to pass to \code{efast} to perform the second-order solution for the Schmid-Leiman method. Defaults to NULL.}

\item{verbose}{Print the convergence progress information. Defaults to TRUE.}
}
\value{
List of class \code{bifactor}.
\item{efa}{List containing objects related to the exploratory factor analysis estimation. See \code{efast}.}
\item{bifactor}{List with the following components:}
\itemize{
\item loadings - Rotated loading matrix.
\item Phi - Factor correlation matrix.
\item T - Transformation matrix.
\item f - Objective value at the minimum.
\item iterations - Number of iterations performed by the rotation algorithm.
\item convergence - Convergence of the rotation algorithm.
\item uniquenesses - Vector of uniquenesses.
\item Rhat - Correlation matrix predicted by the model.
\item Target - Updated target matrix.
\item Weight - Weight matrix. It is the complement of the updated target.
\item GSLiD_iterations - Number of iterations performed by the GSLiD algorithm.
\item GSLiD_convergence - Convergence of the GSLiD algorithm.
\item min_congruences - Vector containing, for each iteration, the minimum Tucker's congruence between
 the current loading matrix and the previous loading matrix.
\item max_abs_diffs - Vector containing, for each iteration, the maximum absolute difference between the
current loading matrix and the previous loading matrix.
}

\item{elapsed}{Total amount of time spent for execution (in nanoseconds).}
}
\description{
Fit an exploratory bi-factor or generalized bi-factor model with correlated factors.
}
\details{
If \code{efa.control = NULL}, then \code{list(maxit = 1e4)} is passed to \code{efa.control}. If \code{rot_control = NULL}, then \code{list(maxit = 1000, eps = 1e-05)} is passed to \code{rot_control}, where \code{eps} is the absolute tolerance. When the objective function does not make a larger improvement than \code{eps}, the algorithm is assumed to converge.

If \code{Target} is provided but not \code{Weight}, then \code{Weight = 1 - Target} by default, which means a partially specified target rotation is performed. The same applies for \code{PhiTarget} and \code{PhiWeight}.

If \code{init = NULL}, then the squared multiple correlations of each item with the remaining ones are used as initial values (These are known to be upper bounds).

If \code{init_Target} is provided, then an initial target by means of the Schmid-Leiman transformation is not necessary.

If \code{cutoff} is not 0, loadings smaller than such a cut-off are fixed to 0. When \code{cutoff} = 0, an empirical cut-off is used for each column of the loading matrix. They are the mean of the one-lagged differences of the sorted squared normalized loadings. Then, the target is determined by fixing to 0 the squared normalized loadings smaller than such cut-offs.
}
\examples{

\dontrun{# Simulate data:
sim <- sim_factor(n_generals = 3, groups_per_general = 5, items_per_group = 6,
generals_rho = 0.3)
scores <- MASS::mvrnorm(1e4, rep(0, nrow(sim$R)), Sigma = sim$R)
s <- cor(scores)

# Fit an Generalized exploratory bi-factor model with GSLiD:
GSLiD <- bifactor(s, n_generals = 3, n_groups = 15, method = "minres",
projection = "poblq", bifactor_method = "GSLiD", oblq_blocks = 3,
random_starts = 10, cores = 8, w = 1, maxit = 20, verbose = TRUE)
}

}
\references{
JimÃ©nez, M., Abad, F.J., Garcia-Garzon, E., Garrido, L.E. (2021, June 24). Generalized exploratory bi-factor Modeling. Under review. Retrieved from https://osf.io/7aszj/?view_only=8f7bd98025104347a96f60a6736f5a64
}
