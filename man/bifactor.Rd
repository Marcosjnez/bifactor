% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/cpp_functions.R
\name{bifactor}
\alias{bifactor}
\title{Fit an exploratory bi-factor model with one or multiple general factors.}
\usage{
bifactor(X, n_generals, n_groups, method = "GSLiD", cor = "pearson",
estimator = "uls", projection = "oblq", nobs = NULL, PhiTarget = NULL,
PhiWeight = NULL, blocks = NULL, block_weights = NULL,
oblq_factors = NULL, init_Target = NULL, maxit = 20L, cutoff = 0,
normalization = "none", w = 1, random_starts = 1L, cores = 1L,
init = NULL, efa_control = NULL, rot_control = NULL, first_efa = NULL,
second_efa = NULL, verbose = TRUE)
}
\arguments{
\item{X}{Raw data matrix or correlation matrix.}

\item{n_generals}{Number of general factors to extract.}

\item{n_groups}{Number of group factors to extract.}

\item{method}{"GSLiD", "SL" (Schmid-Leiman), and "botmin" (bifactor-oblimin-target minimization). Defaults to "GSLiD".}

\item{cor}{Correlation method. Available correlations: c("pearson", "poly"). Defaults to "pearson".}

\item{estimator}{EFA fitting estimator: "ml" (maximum likelihood for multivariate normal variable), "uls" (minimum residuals), "pa" (principal axis) or "minrank" (minimum rank). Defaults to "uls".}

\item{projection}{Projection method. Available projections: "orth" (orthogonal), "oblq" (oblique) and "poblq" (partially oblique). Defaults to "oblq".}

\item{missing}{The way to handle missing data. Options: c("impute.mean", "impute.median", "complete.cases", "pairwise.complete.cases"). Defaults to "pairwise.complete.cases".}

\item{nobs}{Sample size. Defaults to NULL.}

\item{PhiTarget}{Target matrix for the factor correlations. Defaults to NULL.}

\item{PhiWeight}{Weight matrix for the factor correlations. Defaults to NULL.}

\item{blocks}{Vector with the number of factors for which separately applying the rotation criterion. Defaults to NULL.}

\item{block_weights}{Vector of weights for each block of factors.}

\item{oblq_factors}{Vector with the number of factors for each oblique block. E.g.: c(2, 4) means that there are two blocks of oblique factors: one block with 2 factors and another block with 4 factors. Everything else is orthogonal. Defaults to NULL.}

\item{init_Target}{Initial target matrix for the loadings. Defaults to NULL.}

\item{maxit}{Maximum number of iterations for the GSLiD algorithm. Defaults to 20L.}

\item{cutoff}{Cut-off used to update the target matrix upon each iteration. Defaults to 0.}

\item{normalization}{Available normalizations: "kaiser". Defaults to "none".}

\item{w}{\eqn{w} parameter for the extended target criterion ("xtarget"). Defaults to 1L.}

\item{random_starts}{Number of rotations with different random starting values. The rotation with the smallest cost function value is returned. Defaults to 1L.}

\item{cores}{Number of cores for parallel execution of multiple rotations. Defaults to 1L.}

\item{init}{Initial uniquenesses values for exploratory factor analysis estimation. Defaults to NULL.}

\item{efa_control}{List of control parameters for efa fitting. Defaults to NULL.}

\item{rot_control}{List of control parameters for the rotation algorithm. Defaults to NULL.}

\item{first_efa}{List of arguments to pass to \code{efast} to perform the first-order solution for the Schmid-Leiman method. Defaults to NULL.}

\item{second_efa}{List of arguments to pass to \code{efast} to perform the second-order solution for the Schmid-Leiman method. Defaults to NULL.}

\item{verbose}{Print the convergence progress information. Defaults to TRUE.}
}
\value{
List of class \code{bifactor}.
\item{efa}{List containing objects related to the exploratory factor analysis estimation. See \code{efast}.}
\item{bifactor}{List with the following components:}
\itemize{
\item loadings - Rotated loading matrix.
\item Phi - Factor correlation matrix.
\item T - Transformation matrix.
\item f - Objective value at the minimum.
\item iterations - Number of iterations performed by the rotation algorithm.
\item convergence - Convergence of the rotation algorithm.
\item uniquenesses - Vector of uniquenesses.
\item Rhat - Correlation matrix predicted by the model.
\item Target - Updated target matrix.
\item Weight - Weight matrix. It is the complement of the updated target.
\item GSLiD_iterations - Number of iterations performed by the GSLiD algorithm.
\item GSLiD_convergence - Convergence of the GSLiD algorithm.
\item min_congruences - Vector containing, for each iteration, the minimum Tucker's congruence between
 the current loading matrix and the previous loading matrix.
\item max_abs_diffs - Vector containing, for each iteration, the maximum absolute difference between the
current loading matrix and the previous loading matrix.
}

\item{elapsed}{Total amount of time spent for execution (in nanoseconds).}
}
\description{
Jiménez, M., Abad, F. J., Garcia-Garzon, E., & Garrido, L. E. (2023). Exploratory Bi-factor Analysis with Multiple General Factors. Multivariate behavioral research, 1–18. Advance online publication. https://doi.org/10.1080/00273171.2023.2189571
}
\details{
If \code{efa.control = NULL}, then \code{list(maxit = 1e4)} is passed to \code{efa.control}. If \code{rot_control = NULL}, then \code{list(maxit = 1000, eps = 1e-05)} is passed to \code{rot_control}, where \code{eps} is the absolute tolerance. When the objective function does not make a larger improvement than \code{eps}, the algorithm is assumed to converge.

If \code{Target} is provided but not \code{Weight}, then \code{Weight = 1 - Target} by default, which means a partially specified target rotation is performed. The same applies for \code{PhiTarget} and \code{PhiWeight}.

If \code{init = NULL}, then the squared multiple correlations of each item with the remaining ones are used as initial values (These are known to be upper bounds).

If \code{init_Target} is provided, then an initial target by means of the Schmid-Leiman transformation is not necessary.

If \code{cutoff} is not 0, loadings smaller than such a cut-off are fixed to 0. When \code{cutoff} = 0, an empirical cut-off is used for each column of the loading matrix. They are the mean of the one-lagged differences of the sorted squared normalized loadings. Then, the target is determined by fixing to 0 the squared normalized loadings smaller than such cut-offs.
}
\examples{

\dontrun{# Simulate data:
sim <- sim_factor(n_generals = 3, groups_per_general = 5, items_per_group = 6,
generals_rho = 0.3)
scores <- MASS::mvrnorm(1e4, rep(0, nrow(sim$R)), Sigma = sim$R)
s <- cor(scores)

# Fit an exploratory bi-factor model with GSLiD:
fit <- bifactor(s, n_generals = 3, n_groups = 15, method = "GSLiD",
estimator = "uls", projection = "poblq", nobs = NULL, oblq_factors = 3,
random_starts = 10, cores = 8, w = 1, maxit = 20, verbose = TRUE, normalization = "none")
}

}
\references{
Jiménez, M., Abad, F. J., Garcia-Garzon, E., & Garrido, L. E. (2023). Exploratory Bi-factor Analysis with Multiple General Factors. Multivariate behavioral research, 1–18. Advance online publication. https://doi.org/10.1080/00273171.2023.2189571
}
