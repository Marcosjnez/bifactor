% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/cpp_functions.R
\name{rotate}
\alias{rotate}
\title{Fast rotation algorithm for factor analysis.}
\usage{
rotate(loadings, rotation = "oblimin", projection = "oblq",
gamma = 0, epsilon = 0.01, k = 0, w = 1, alpha = 1,
Target = NULL, Weight = NULL, PhiTarget = NULL, PhiWeight = NULL,
blocks = NULL, blocks_list = NULL, block_weights = NULL, oblq_blocks = NULL,
penalization = "none", rot_control = NULL, random_starts = 1L, cores = 1L)
}
\arguments{
\item{loadings}{Unrotated loading matrix.}

\item{rotation}{Rotation criterion. Available rotations: "varimax", "cf" (Crawford-Ferguson), "oblimin", "geomin", "target", "xtarget" (extended target) and "none". Defaults to "oblimin".}

\item{projection}{Projection method. Available projections: "orth" (orthogonal), "oblq" (oblique), "poblq" (partially oblique). Defaults to "oblq".}

\item{gamma}{\eqn{\gamma} parameter for the oblimin criterion. Defaults to 0 (quartimin).}

\item{epsilon}{\eqn{\epsilon} parameter for the geomin criterion. Defaults to 0.01.}

\item{k}{\eqn{k} parameter for the Crawford-Ferguson family of rotation criteria. Defaults to 0.}

\item{w}{\eqn{w} parameter for the extended target criterion ("xtarget"). Defaults to 1.}

\item{alpha}{\eqn{\alpha} parameter for the Tian and Liu penalization. Defaults to 1.}

\item{Target}{Target matrix for the loadings. Defaults to NULL.}

\item{Weight}{Weight matrix for the loadings. Defaults to NULL.}

\item{PhiTarget}{Target matrix for the factor correlations. Defaults to NULL.}

\item{PhiWeight}{Weight matrix for the factor correlations. Defaults to NULL.}

\item{blocks}{Vector with the number of factors for which separately applying the rotation criterion. Defaults to NULL.}

\item{blocks_list}{List containing the vectors with the columns to which applying the rotation criterion.}

\item{block_weights}{Vector of weights for each block of factors.}

\item{oblq_blocks}{Vector with the number of factors for each oblique block. E.g.: c(2, 4) means that there are two blocks of oblique factors: one block with 2 factors and another block with 4 factors. Everything else is orthogonal. Defaults to NULL.}

\item{penalization}{Available penalizations: "TL" and "TLM". Defaults to none.}

\item{rot_control}{List of control parameters for the rotation algorithm. Defaults to NULL.}

\item{random_starts}{Number of rotations with different random starting values. The rotation with the smallest cost function value is returned. Defaults to 1L.}

\item{cores}{Number of cores for parallel execution of random starts. Defaults to 1L.}
}
\value{
List of class \code{rotation} with the following components:
\item{loadings}{Rotated loading matrix.}
\item{Phi}{Correlation matrix among the factors.}
\item{T}{Rotation matrix.}
\item{f}{Objective value at the minimum.}
\item{iterations}{Number of iterations for the rotation algorithm to converge.}
\item{convergence}{TRUE if the algorithm converged and FALSE otherwise.}
\item{elapsed}{Total amount of time spent for execution (in nanoseconds).}
}
\description{
Riemannian Newton Trust-Region algorithm to quickly perform (parallel) rotations with different random starting values.
}
\details{
If \code{rot_control = NULL}, then \code{list(maxit = 1000, eps = 1e-05)} is passed to \code{rot_control}, where \code{eps} is the absolute tolerance. When the objective function does not make a larger improvement than \code{eps}, the algorithm is assumed to converge.
If \code{Target} is provided but not \code{Weight}, then \code{Weight = 1 - Target} by default, which means a partially specified target rotation is performed. The same applies for \code{PhiTarget} and \code{PhiWeight}.
}
\references{
Jiménez, M., Abad, F.J., Garcia-Garzon, E., Garrido, L.E. (2021, June 24). Generalized exploratory bi-factor Modeling. Under review. Retrieved from https://osf.io/7aszj/?view_only=8f7bd98025104347a96f60a6736f5a64

Zhang, G., Hattori, M., Trichtinger, L. A., & Wang, X. (2019). Target rotation with both factor loadings and factor correlations. Psychological Methods, 24(3), 390–402. https://doi.org/10.1037/met0000198
}
